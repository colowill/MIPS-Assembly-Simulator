/**
 * Do not edit this file
 *
 * Contains helper functions for MIPS simulator, such as parse_cli, print_state,
 * etc.
 */

#include "utils.h"

#include <getopt.h>
#include <limits.h>
#include <linux/limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

cli_args parse_cli(int argc, char* argv[]) {
    char* filepath = (char*)malloc(PATH_MAX * sizeof(char));
    cli_args rv = {.filepath = filepath,
                   .disp_array = false,
                   .step_mode = false,
                   .disp_hex = false};

    // See https://linux.die.net/man/3/getopt, notes section
    // Without this, freeing argv will corrupt memory because getopt mutates
    // argv Normally this is okay because argv would normally be stack-allocated
    // and not freed But not okay given that we need to dynamically allocate it
    // in tests.cpp
    optind = 0;
    char opt;
    while ((opt = getopt(argc, argv, "ashmx")) != -1) {
        switch (opt) {
            case 'a':
                rv.disp_array = true;
                break;
            case 's':
                rv.step_mode = true;
                break;
            case 'h':
                printf(
                    "Usage: ./main [-ashmx] hex_file\n\n"
                    "hex_file must contain MIPS instructions in hex format "
                    "(i.e., each line is a single string of 8 hexits).\n"
                    "To see how to generate such a file, run with flag -m.\n\n"
                    "Options:\n"
                    "\t-a: print registers as array (for autograding)\n"
                    "\t-s: step mode (execution blocks on user input)\n"
                    "\t-h: print this help message\n"
                    "\t-m: print steps for using Mars as an IDE for writing "
                    "MIPS code and translating multiple MIPS instructions to "
                    "hex\n"
                    "\t-x: print register values in hex\n");
                free(filepath);
                exit(0);
            case 'm':
                printf(
                    "If you want an IDE for writing MIPS code (with "
                    "autocomplete) or if you "
                    "want to translate multiple instructions to hex, follow "
                    "these steps:\n\n"
                    "1. Download Mars4_5.jar "
                    "[here](https://courses.missouristate.edu/KenVollmar/MARS/"
                    ") or "
                    "[here](https://drive.google.com/file/d/"
                    "1xm2M-h0SaoEU7Ps_fkmh94P0czav3Hus/view?usp=sharing) (if "
                    "previous website is down)\n"
                    "2. In your host OS (not Docker container), run the .jar "
                    "file with java -jar Mars4_5.jar. Use the correct path, "
                    "and this also requires Java to be installed\n"
                    "3. In the Mars GUI, use File > New or File > Open to "
                    "create or open a .asm file\n"
                    "4. Set Settings > Memory Configuration to \"Compact, Text "
                    "at Address 0\" (one-time config)\n"
                    "5. Write your MIPS code\n"
                    "6. Click Run > Assemble\n"
                    "7. To run the code, click Run > Go\n"
                    "Or, to translate the code to hex, click File > Dump "
                    "Memory, set Dump Format to "
                    "Hexadecimal Text, and click Dump To File to save the file "
                    "somewhere\n"
                    "For more instructions for using MARS, see the website "
                    "above (if it is not down)\n");
                free(filepath);
                exit(0);
            case 'x':
                rv.disp_hex = true;
                break;
            default:
                fprintf(stderr, "For correct usage, type ./main -h\n");
                free(filepath);
                exit(1);
        }
    }
    if (optind != argc - 1) {
        fprintf(stderr,
                "Expected 1 file after option(s), if any. For correct usage, "
                "type ./main -h\n");
        free(filepath);
        exit(1);
    }
    strcpy(rv.filepath, argv[optind]);

    return rv;
}

void print_state(int32_t* registers, uint32_t pc, bool disp_array,
                 bool disp_hex) {
    if (disp_array) {
        printf("[");
        for (int i = 0; i < NUM_REGISTERS; i++)
            printf(disp_hex ? "0x%08x, " : "%d, ", registers[i]);
        printf(disp_hex ? "0x%08x]\n" : "%d]\n", pc);
    } else {
        printf("| Name |    Value   |\n");
        printf("---------------------\n");
        for (int i = 0; i < NUM_REGISTERS; i++)
            printf(disp_hex ? "|  $%2d | 0x%08x |\n" : "|  $%2d | %10d |\n", i,
                   registers[i]);
        printf(disp_hex ? "|   PC | 0x%08x |\n" : "|   PC |  %9d |\n", pc);
    }
}

bool validate_pc(uint32_t pc) { return pc % WORD_SIZE == 0; }

void execute_all(uint32_t* instructions, uint32_t num_instructions,
                 int32_t* registers, uint32_t* pc, cli_args flags) {
    if (flags.step_mode)
        printf("Press enter to execute the next instruction\n");
    while ((*pc) < num_instructions * WORD_SIZE) {
        if (flags.step_mode) getchar();

        if (!validate_pc(*pc)) {
            fprintf(stderr, "Invalid PC (not a multiple of word size %d): %d\n",
                    WORD_SIZE, *pc);
            fprintf(stderr,
                    "Consider running the program in step mode to find what "
                    "caused this error\n");
            free(flags.filepath);
            exit(1);
        }

        instruction* instruct = create_instruction(instructions[(*pc) >> 2]);
        execute_instruction(instruct, registers, pc);
        free(instruct);

        if (flags.step_mode)
            print_state(registers, *pc, flags.disp_array, flags.disp_hex);
    }
    if (!flags.step_mode)
        print_state(registers, *pc, flags.disp_array, flags.disp_hex);
}

uint32_t hex_instruction_file_to_array(const char* filepath,
                                       uint32_t* instructions) {
    FILE* file;
    file = fopen(filepath, "r");
    if (file == NULL) {
        fprintf(stderr, "Failed to open file %s\n", filepath);
        exit(1);
    }

    uint32_t num_instructions = 0;
    char* line = NULL;
    size_t size = 0;
    while (getline(&line, &size, file) != -1)
        instructions[num_instructions++] = (uint32_t)strtoul(line, NULL, 16);

    free(line);
    fclose(file);

    return num_instructions;
}
